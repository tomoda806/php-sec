# PHP App ② レビュー

## XSS(クロスサイトスクリプティング)

### XSSとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
Webサイトの脆弱性を利用し、HTMLで悪質なコードをスクリプトとして実行させ、別のWebサイトにユーザーを誘導する攻撃。
ユーザーが標的サイトを閲覧するだけで攻撃が実行される為、被害が拡大しやすい。

### `htmlspecialchars()`を`e()`として定義しなおすメリットを説明してください。
文字を変換するときに使うエンコーディング（flags定数、文字セット等）を定義しておけば、短い記述で再利用できる。

### `htmlspecialchars()`を使うことでなぜXSSが防げるのか説明してください。
htmlspecialcharsは、 &, “などの特殊文字をHTMLエンティティに変換することで、悪質なスクリプトが実行されるのをを防ぐ。
<!-- HTMLエンティティとは、'&'で始まって';'で終わる文字列の固まり。 -->

## CSRF(クロスサイトリクエストフォージェリ)

### CSRFとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
WEBサイトへログイン状態の時、攻撃者が用意した罠サイトによってリクエストが偽造され、ユーザーが意図しない処理を強制的に実行されてしまう。
被害者のアカウントでの操作や機密情報へのアクセスが可能になる。

### SessionとCookieの違いを説明してください。
Cookieはユーザーのブラウザ側に保存されるのに対し、Sessionはサーバー側で管理される。
Cookieはログイン情報の保存とログイン状態の保持などに使用する。
Sessionはショッピングサイトなどでカートの中身や設定内容など、利用者ごとの機能を提供するために状態を保持して識別する。

### `setToken()`が何をしているか説明してください。
SESSIONにトークンを格納。
16文字のランダムな文字列を生成し、文字列を16進数に変換、生成された値を$_SESSION['token'] に格納している。

### `checkToken()`が何をしているか説明してください。
サーバ側とクライアント側のtokenの整合性を確認し、一致しない場合は'不正な操作です'というエラー文がSESSIONに格納される。

### トークンを使うことでなぜCSRFが防げるのか説明してください。
登録実行時、トークンが一致しない場合は、リクエストを処理しないようにすることで攻撃を防ぐ事ができる。
<!-- トークン：攻撃者に推測されにくい任意の情報 -->

## SQLインジェクション

### SQLインジェクションとはどんな攻撃か、また攻撃者にどんなメリットがあるか説明してください。
Webサイトやアプリケーションの脆弱性を狙って、検索欄などの入力フィールドに不正なSQL文を挿入し実行させる攻撃。
DBに保存されたデータを、不正に読み取ったり改ざんや削除できる。

### `->prepare()`の返り値と、またこのメソッドが何をしているか説明してください。
クエリを実行するために必要なSQL文を事前に準備するメソッド。
データベースサーバーが正常に文を準備できた場合は、PDOStatementオブジェクトを返す。
上記が準備できなかった場合は、falseかPDOExceptionを返す。

### `->bindValue()`が何をしているか説明してください。
DBアクセス時にSQL文の中でプレースホルダーに値をバインドする。
DBに対して数値を変化させながら繰り返し同様の処理を行う場合、毎回SQL文の数値を設定し直すと効率が悪くなるため、
バインド変数を使用している。
<!-- プレースホルダー：SQL文の中で値が変動する部分に用いる文字列や記号。（:id） -->

### 今回の対策でなぜSQLインジェクションが防げるのか説明してください。
'bindValue()'の引数に、対象の文字列・保存したい値・データ型を指定し文字列として認識させ、プレースホルダーに値をセットすることで、SQL文を悪意のある攻撃から守ることができる。

## バリデーション

### バリデーションの目的について説明してください。
入力された値が正しい値かどうかをチェックするのが目的。
数字の項目に文字を入力してたり、入力形式が合っているか等確認し、正しい値の再入力を促す。

### `validate()`が何をしているか説明してください。
POSTデータが空の場合は、「入力がありません」と表示させて新規作成ページに遷移している。

### `isset($post['content'])`はなぜ必要か、無い場合どうなるか説明してください。
'$post'に'content'キーが定義されているか確認してから値をチェックすることで、未定義のエラーを防ぐことができる。
無い場合、未定義の配列キーですとエラーになってしまう。
今回の場合、削除処理で'content'キーは使用しない為エラーになる。

## その他

### `unsetError()`を実行しないとどうなるか説明してください。
バリデーションエラー発生後に表示される文言が、一覧画面に遷移しても消えずに残り続けてしまう。
